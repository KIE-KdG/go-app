{{define "scripts"}}
<script>
  function chatApp() {
    return {
      ws: null,
      inputMessage: '',
      messages: [],
      currentResponse: null,
      dbUsed: false,
      docsUsed: false,
      isProcessing: false,
      reconnectAttempts: 0,
      maxReconnectAttempts: 5,
      reconnectTimeout: null,
      showScrollButton: false,
      responseStartTime: null,
      hasMap: false,
      mapOverlayVisible: false,
      isFullscreen: false,
      currentGeoJSON: null,
      overlayMap: null,
      mapStyles: {},
      
      init() {
        // Initialize values to prevent errors
        console.log("Initializing chat app");
        
        // Initialize WebSocket connection
        this.initWebSocket();
        
        this.$nextTick(() => {
          this.scrollToBottom();
          this.autoResizeTextarea();
        });
        
        // Handle escape key for closing map overlay
        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.mapOverlayVisible) {
            this.closeMapOverlay();
          }
        });
        
        // Handle fullscreen changes
        document.addEventListener('fullscreenchange', () => {
          this.isFullscreen = !!document.fullscreenElement;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
          if (this.overlayMap && this.mapOverlayVisible) {
            setTimeout(() => {
              this.overlayMap.invalidateSize();
            }, 200);
          }
        });
      },
      
      // Initialize WebSocket connection
      initWebSocket() {
        const chatID = window.location.pathname.split("/")[2];
        if (!chatID) {
          console.error("No chat ID found in URL");
          return;
        }
        
        this.ws = new WebSocket(`wss://localhost:4000/ws/${chatID}`);
        
        this.ws.addEventListener('open', () => {
          console.log('WebSocket connection established');
          this.reconnectAttempts = 0; // Reset reconnect attempts on successful connection
        });
        
        this.ws.addEventListener('message', (event) => {
          let data = {};
          try {
            data = JSON.parse(event.data);
          } catch (e) {
            console.error('Error parsing JSON:', event.data);
            return;
          }
          
          // Handle possible interruption acknowledgment
          if (data.interrupted) {
            console.log("Server acknowledged interruption");
            this.isProcessing = false;
            
            if (this.currentResponse) {
              if (!this.currentResponse.answer) {
                this.currentResponse.answer = "*Generation was interrupted.*";
              }
              
              if (this.responseStartTime) {
                const responseTime = new Date() - this.responseStartTime;
                this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (interrupted)";
                this.responseStartTime = null;
              }
              
              this.currentResponse = null;
            }
            
            return;
          }
          
          // Create response object if it doesn't exist yet
          if (!this.currentResponse) {
            this.messages.push({
              sender: 'AI',
              statusUpdates: [],
              answer: '',
              geoJSON: null
            });
            this.currentResponse = this.messages[this.messages.length - 1];
          }
          
          // Handle status updates
          if (data.status) {
            this.currentResponse.statusUpdates.push(data.status.trim());
          }
          
          // Handle answer data (look for both answer and response fields)
          if (data.answer || data.response) {
            const responseText = data.answer || data.response;
            this.currentResponse.answer = responseText;
          }
          
          // Handle GeoJSON data
          if (data.geoJSON) {
            console.log("Received GeoJSON data");
            
            let parsedGeoJSON = data.geoJSON;
            // If it's a string, parse it to make sure it's valid
            if (typeof data.geoJSON === 'string') {
              try {
                // Just to validate, we'll keep the original string
                JSON.parse(data.geoJSON);
                console.log("Valid GeoJSON string");
              } catch (e) {
                console.error("Failed to parse GeoJSON string:", e);
                // Not valid JSON, don't add it
                return;
              }
            }
            
            // Store the GeoJSON in the current response
            this.currentResponse.geoJSON = parsedGeoJSON;
            
            // Set flag indicating maps are available
            this.hasMap = true;
          }
          
          // Finalize the response if we have answer or GeoJSON
          if (data.answer || data.response || data.geoJSON) {
            // Calculate response time
            if (this.responseStartTime) {
              const responseTime = new Date() - this.responseStartTime;
              this.currentResponse.responseTime = this.formatResponseTime(responseTime);
              this.responseStartTime = null;
            }
            
            this.currentResponse = null;
            this.isProcessing = false;
          }
          
          this.$nextTick(() => {
            this.scrollToBottom();
          });
        });
        
        this.ws.addEventListener('close', (event) => {
          console.log('WebSocket connection closed', event);
          
          // If we were in the middle of a response, mark it as incomplete
          if (this.isProcessing) {
            if (this.currentResponse) {
              this.currentResponse.statusUpdates.push("Connection closed unexpectedly. Please try again.");
              this.currentResponse.answer = this.currentResponse.answer || "Response interrupted. Please try again.";
              
              // Add response time even for incomplete responses
              if (this.responseStartTime) {
                const responseTime = new Date() - this.responseStartTime;
                this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (incomplete)";
                this.responseStartTime = null;
              }
              
              this.currentResponse = null;
            }
            this.isProcessing = false;
          }
          
          // Attempt to reconnect if not a normal closure and within max attempts
          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
            const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts), 10000);
            console.log(`Attempting to reconnect in ${delay}ms...`);
            
            this.reconnectTimeout = setTimeout(() => {
              this.reconnectAttempts++;
              this.initWebSocket();
            }, delay);
          }
        });
        
        this.ws.addEventListener('error', (error) => {
          console.error('WebSocket error:', error);
        });
      },
      
      // Open map overlay with the given GeoJSON data
      openMapOverlay(geoJSON) {
        console.log("Opening map overlay with GeoJSON data:", geoJSON ? "yes" : "no");
        if (!geoJSON) {
          console.error("No GeoJSON data provided");
          return;
        }
        
        this.currentGeoJSON = geoJSON;
        console.log("Setting mapOverlayVisible to true");
        this.mapOverlayVisible = true;
        console.log("mapOverlayVisible is now:", this.mapOverlayVisible);
        
        // Initialize the map after the overlay is visible
        this.$nextTick(() => {
          setTimeout(() => {
            this.initOverlayMap();
          }, 300);
        });
      },
      
      // Close the map overlay
      closeMapOverlay() {
        // Exit fullscreen if active
        if (this.isFullscreen && document.exitFullscreen) {
          document.exitFullscreen();
        }
        
        this.mapOverlayVisible = false;
      },
      
      // Toggle fullscreen for the map overlay
      toggleFullscreen() {
        const mapContainer = document.querySelector('.map-overlay');
        
        if (!mapContainer) return;
        
        if (!this.isFullscreen) {
          if (mapContainer.requestFullscreen) {
            mapContainer.requestFullscreen();
          } else if (mapContainer.mozRequestFullScreen) {
            mapContainer.mozRequestFullScreen();
          } else if (mapContainer.webkitRequestFullscreen) {
            mapContainer.webkitRequestFullscreen();
          } else if (mapContainer.msRequestFullscreen) {
            mapContainer.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      },
      
      // Initialize the overlay map
      initOverlayMap() {
        const mapContainer = document.getElementById('overlay-map');
        if (!mapContainer || !this.currentGeoJSON) {
          console.error("Missing map container or GeoJSON data");
          return;
        }
        
        try {
          console.log("Initializing overlay map");
          
          // Check if Leaflet is loaded
          if (typeof L === 'undefined') {
            console.error("Leaflet is not loaded");
            return;
          }
          
          // If map already exists, just update the GeoJSON and refresh
          if (this.overlayMap) {
            this.addGeoJSONToMap(this.overlayMap, this.currentGeoJSON);
            this.overlayMap.invalidateSize();
            return;
          }
          
          // Initialize new map
          this.overlayMap = L.map('overlay-map', {
            center: [51.05, 3.7], // Default to Belgium
            zoom: 10,
            maxZoom: 18
          });
          
          // Initialize map styles
          this.mapStyles.overlay = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
              attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            }),
            topo: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
              attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery Â© <a href="https://opentopomap.org">OpenTopoMap</a>'
            })
          };
          
          // Add default basemap
          this.mapStyles.overlay.osm.addTo(this.overlayMap);
          
          // Add GeoJSON data
          console.log("Adding GeoJSON to map");
          this.addGeoJSONToMap(this.overlayMap, this.currentGeoJSON);
          
          // Force a size refresh
          setTimeout(() => {
            console.log("Refreshing map size");
            if (this.overlayMap) {
              this.overlayMap.invalidateSize();
            }
          }, 200);
        } catch (e) {
          console.error("Error initializing overlay map:", e);
        }
      },
      
      // Change map style
      changeMapStyle(style, mapType = 'overlay') {
        if (!this.mapStyles[mapType]) return;
        
        const map = mapType === 'overlay' ? this.overlayMap : null;
        if (!map) return;
        
        const styles = this.mapStyles[mapType];
        
        // Remove all base layers
        Object.values(styles).forEach(layer => {
          if (map.hasLayer(layer)) {
            map.removeLayer(layer);
          }
        });
        
        // Add selected base layer
        if (styles[style]) {
          styles[style].addTo(map);
        }
      },
      
      // Reset map view to fit all features
      resetMapView(mapType = 'overlay') {
        const map = mapType === 'overlay' ? this.overlayMap : null;
        if (!map) return;
        
        // Find all GeoJSON layers
        map.eachLayer(layer => {
          if (layer instanceof L.GeoJSON) {
            try {
              if (layer.getBounds && typeof layer.getBounds === 'function') {
                const bounds = layer.getBounds();
                if (bounds && bounds.isValid()) {
                  map.fitBounds(bounds, { padding: [30, 30] });
                }
              }
            } catch (e) {
              console.warn("Could not fit to bounds:", e);
              map.setView([51.05, 3.7], 10);
            }
          }
        });
      },
      
      // Add GeoJSON to a map with error handling
      addGeoJSONToMap(map, geoJSONData) {
        if (!map) return;
        
        // Clear existing GeoJSON layers
        map.eachLayer(layer => {
          if (layer instanceof L.GeoJSON) {
            map.removeLayer(layer);
          }
        });
        
        try {
          // Parse GeoJSON if it's a string
          let geoJSON = geoJSONData;
          if (typeof geoJSONData === 'string') {
            try {
              geoJSON = JSON.parse(geoJSONData);
            } catch (e) {
              console.error("Error parsing GeoJSON string:", e);
              return;
            }
          }
          
          // Feature styling
          const geoJsonOptions = {
            style: (feature) => {
              return {
                weight: 2,
                opacity: 1,
                color: '#3388ff',
                fillOpacity: 0.5,
                fillColor: this.getFeatureColor(feature)
              };
            },
            pointToLayer: (feature, latlng) => {
              return L.circleMarker(latlng, {
                radius: 8,
                fillColor: this.getFeatureColor(feature),
                color: '#000',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
              });
            },
            onEachFeature: (feature, layer) => {
              // Add popups for properties
              if (feature.properties) {
                const popupContent = Object.entries(feature.properties)
                  .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                  .join('<br>');
                
                if (popupContent) {
                  layer.bindPopup(popupContent);
                }
              }
              
              // Add hover effects
              layer.on({
                mouseover: (e) => {
                  const layer = e.target;
                  layer.setStyle({
                    weight: 3,
                    color: '#666',
                    dashArray: '',
                    fillOpacity: 0.7
                  });
                  
                  if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                    layer.bringToFront();
                  }
                },
                mouseout: (e) => {
                  const geoJsonLayer = e.target._eventParents ? 
                    Object.values(e.target._eventParents)[0] : null;
                  
                  if (geoJsonLayer) {
                    geoJsonLayer.resetStyle(e.target);
                  }
                }
              });
            }
          };
          
          // Create and add GeoJSON layer
          const geoLayer = L.geoJSON(geoJSON, geoJsonOptions).addTo(map);
          
          // Fit bounds to GeoJSON - with better error handling
          try {
            // First check if the layer has a getBounds method
            if (geoLayer.getBounds && typeof geoLayer.getBounds === 'function') {
              const bounds = geoLayer.getBounds();
              
              // Check if bounds exist and are valid
              if (bounds && bounds.isValid()) {
                map.fitBounds(bounds, { padding: [30, 30] });
                console.log("Successfully fit map to bounds");
              } else {
                console.warn("Invalid or empty bounds");
                map.setView([51.05, 3.7], 10);
              }
            } else {
              console.warn("Layer doesn't have getBounds method");
              map.setView([51.05, 3.7], 10);
            }
          } catch (e) {
            console.warn("Could not fit to bounds:", e);
            map.setView([51.05, 3.7], 10);
          }
        } catch (e) {
          console.error("Error adding GeoJSON to map:", e);
        }
      },
      
      // Get color for feature
      getFeatureColor(feature) {
        if (!feature.properties) return '#3388ff';
        
        if (feature.properties.type) {
          const type = feature.properties.type.toLowerCase();
          if (type.includes('water') || type.includes('river') || type.includes('lake')) {
            return '#0077be';  // Blue for water
          } else if (type.includes('forest') || type.includes('park') || type.includes('green')) {
            return '#228B22';  // Green for vegetation
          } else if (type.includes('building') || type.includes('urban')) {
            return '#CD5C5C';  // Red for urban
          }
        }
        
        if (feature.properties.status) {
          const status = feature.properties.status.toLowerCase();
          if (status.includes('occupied')) {
            return '#FF5733';  // Red for occupied
          } else if (status.includes('available')) {
            return '#33FF57';  // Green for available
          } else if (status.includes('maintenance')) {
            return '#FFFF33';  // Yellow for maintenance
          }
        }
        
        return '#3388ff';  // Default blue
      },
      
      // Count features in GeoJSON
      getFeatureCount(geoJSON) {
        if (!geoJSON) return 0;
        
        try {
          let data = geoJSON;
          if (typeof geoJSON === 'string') {
            data = JSON.parse(geoJSON);
          }
          
          if (data.features && Array.isArray(data.features)) {
            return data.features.length;
          } else if (data.type === 'Feature') {
            return 1;
          }
        } catch (e) {
          console.error("Error counting features:", e);
        }
        
        return 0;
      },
      
      // Method to interrupt the generation
      interruptGeneration() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN && this.isProcessing) {
          // Send interrupt command to the server
          this.ws.send(JSON.stringify({
            interrupt: true
          }));
          
          // Update the current response to show it was interrupted
          if (this.currentResponse) {
            this.currentResponse.statusUpdates.push("Generation interrupted by user.");
            
            // Finalize the current response even if incomplete
            if (this.responseStartTime) {
              const responseTime = new Date() - this.responseStartTime;
              this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (interrupted)";
              this.responseStartTime = null;
            }
            
            // If there's no answer yet, add a message indicating interruption
            if (!this.currentResponse.answer) {
              this.currentResponse.answer = "*Generation was interrupted.*";
            }
            
            this.currentResponse = null;
          }
          
          // Reset processing state immediately
          this.isProcessing = false;
        }
      },
      
      sendMessage() {
        if (!this.inputMessage.trim() || this.isProcessing) return;
        
        // Check WebSocket state
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          console.error('WebSocket is not open');
          // Try to reconnect
          if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
          }
          this.initWebSocket();
          return;
        }
        
        this.isProcessing = true; // Disable input form while processing
        this.responseStartTime = new Date(); // Start timing the response
        
        this.messages.push({
          sender: 'You',
          text: this.inputMessage
        });
        
        this.messages.push({
          sender: 'AI',
          statusUpdates: [],
          answer: '',
          geoJSON: null
        });
        
        this.currentResponse = this.messages[this.messages.length - 1];
        
        this.ws.send(JSON.stringify({
          message: this.inputMessage,
          dbUsed: this.dbUsed,
          docsUsed: this.docsUsed
        }));
        
        this.inputMessage = '';
        this.$nextTick(() => {
          this.scrollToBottom();
          this.autoResizeTextarea();
        });
      },
      
      scrollToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      },
      
      checkScroll() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          // Show button if user has scrolled up at least 200px from bottom
          this.showScrollButton = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight > 200;
        }
      },
      
      formatResponseTime(milliseconds) {
        if (milliseconds < 1000) {
          return `${milliseconds}ms`;
        } else if (milliseconds < 60000) {
          return `${(milliseconds / 1000).toFixed(1)}s`;
        } else {
          const minutes = Math.floor(milliseconds / 60000);
          const seconds = ((milliseconds % 60000) / 1000).toFixed(1);
          return `${minutes}m ${seconds}s`;
        }
      },
      
      formatTimestamp(timestamp) {
        if (!timestamp) return '';
        
        try {
          const date = new Date(timestamp);
          return date.toLocaleString();
        } catch (e) {
          return timestamp.toString();
        }
      },
      
      formatMarkdown(text) {
        if (!text) return '';
        // Make sure marked is loaded
        if (window.marked) {
          try {
            return window.marked.parse(text);
          } catch (e) {
            console.error('Error parsing markdown:', e);
            return text;
          }
        }
        return text; // Fallback if marked.js isn't loaded yet
      },
      
      autoResizeTextarea() {
        const textarea = this.$refs.messageInput;
        if (textarea) {
          // Reset height to get proper scrollHeight
          textarea.style.height = 'auto';
          
          // Set new height (with min/max constraints handled by CSS)
          const newHeight = Math.min(Math.max(textarea.scrollHeight, 60), 200);
          textarea.style.height = `${newHeight}px`;
        }
      }
    };
  }
</script>
{{end}}