{{define "chat"}}
<div class="min-h-screen flex flex-col relative" 
  x-data="chatApp()" 
  x-init="init()" 
  :class="{'max-w-3xl mx-auto': !hasMap || !mapVisible, 'max-w-6xl mx-auto grid grid-cols-3': hasMap && mapVisible}">
  
  <!-- Chat messages container -->
  <div class="flex flex-col flex-1" :class="{'col-span-2': hasMap && mapVisible}">
    <div id="chatMessages" class="flex-1 flex flex-col gap-3 px-4 pt-1 overflow-auto" @scroll="checkScroll()">
      {{range .Messages}}
      {{/* Compute background class based on sender type */}}
      {{ $bgClass := "" }}
      {{ if eq .SenderType "You" }}
      {{ $bgClass = "bg-blue-100 dark:bg-blue-900" }}
      {{ else if eq .SenderType "AI" }}
      {{ $bgClass = "bg-green-100 dark:bg-green-900" }}
      {{ end }}
      <div class="chat-message p-2 rounded shadow-md text-black dark:text-white {{$bgClass}}">
        <div class="sender font-bold">
          {{ if eq .SenderType "You" }}You{{ else if eq .SenderType "AI" }}AI{{ end }}
        </div>
        <pre class="message-text whitespace-pre-wrap text-black dark:text-white">{{.Content}}</pre>
      </div>
      {{end}}
      <template x-for="(message, index) in messages" :key="index">
        <div class="chat-message p-2 rounded shadow-md text-black dark:text-white"
          :class="{'bg-blue-100 dark:bg-blue-900': message.sender === 'You', 'bg-green-100 dark:bg-green-900': message.sender=== 'AI'}">
          <div class="sender font-bold" x-html="message.sender"></div>

          <!-- AI Response Block -->
          <template x-if="message.sender === 'AI'">
            <div>
              <!-- Response time display -->
              <div x-show="message.responseTime" class="text-xs text-gray-500 dark:text-gray-400 mb-1">
                Response time: <span x-text="message.responseTime"></span>
              </div>

              <!-- Current status display -->
              <div x-show="message.statusUpdates && message.statusUpdates.length > 0" class="mb-2">
                <div class="text-sm text-blue-600 dark:text-blue-400"
                  x-text="message.statusUpdates[message.statusUpdates.length - 1]"></div>

                <!-- Modified dropdown to be wider -->
                <details class="dropdown mt-1" x-show="message.statusUpdates.length > 1">
                  <summary class="cursor-pointer text-xs text-blue-600 dark:text-blue-400">View all status updates
                  </summary>
                  <div class="dropdown-content p-2 bg-white dark:bg-gray-700 rounded shadow w-64 md:w-96">
                    <template x-for="(status, i) in message.statusUpdates" :key="i">
                      <p class="text-sm text-black dark:text-white py-1" x-text="status"></p>
                    </template>
                  </div>
                </details>
              </div>

              <!-- Actual response with markdown support -->
              <div x-show="message.answer" class="markdown-content text-black dark:text-white"
                x-html="formatMarkdown(message.answer)"></div>
              
              <!-- Inline map display (only for mobile or when side map is hidden) -->
              <div x-show="message.geoJSON && (!mapVisible || window.innerWidth < 768)" class="mt-4">
                <div class="text-sm font-bold mb-2">Map Data:</div>
                <div :id="'mobile-map-' + index" class="h-64 w-full rounded-lg shadow-md"></div>
                <div x-init="$nextTick(() => { if (message.geoJSON) initMap('mobile-map-' + index, message.geoJSON); })"></div>
              </div>
            </div>
          </template>

          <!-- User message -->
          <template x-if="message.sender === 'You'">
            <pre class="message-text whitespace-pre-wrap text-black dark:text-white" x-text="message.text"></pre>
          </template>
        </div>
      </template>
    </div>

    <!-- Chat Input Form -->
    <div class="card bg-base-100 w-full shadow-xl sticky bottom-0 z-0">
      <div class="p-6 relative">
        <form @submit.prevent="!isProcessing && inputMessage.trim() ? sendMessage() : null" class="relative w-full">
          <div class="relative">
            <textarea id="messageInput" x-model="inputMessage"
              @keydown.enter.prevent="!isProcessing && inputMessage.trim() ? sendMessage() : null"
              placeholder="Type your message" :disabled="isProcessing" x-ref="messageInput" @input="autoResizeTextarea"
              class="input w-full px-3 py-2 resize-none overflow-hidden rounded bg-base-200 dark:bg-base-200 focus:outline-none"
              :class="{'opacity-75': isProcessing}" style="min-height: 60px; max-height: 200px;"></textarea>
          </div>

          <div class="card-actions justify-start mt-2">
            <label class="flex min-w-8 h-9"
              :class="{'btn': true, 'btn-primary': dbUsed, 'btn-outline': !dbUsed, 'rounded-full': true, 'opacity-75 cursor-not-allowed': isProcessing}">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="bevel">
                <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
              </svg>
              <input type="checkbox" x-model="dbUsed" class="hidden" :disabled="isProcessing">
              DB
            </label>
            <label class="flex min-w-8 h-9"
              :class="{'btn': true, 'btn-primary': docsUsed, 'btn-outline': !docsUsed, 'rounded-full': true, 'opacity-75 cursor-not-allowed': isProcessing}">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="bevel">
                <path d="M13 2H6a2 2 0 0 0-2 2v16c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V9l-7-7z" />
                <path d="M13 3v6h6" />
              </svg>
              <input type="checkbox" x-model="docsUsed" class="hidden" :disabled="isProcessing">
              Docs
            </label>
            
            <!-- Toggle map button (only visible when map exists) -->
            <label x-show="hasMap" class="flex min-w-8 h-9 ml-2"
              :class="{'btn': true, 'btn-primary': mapVisible, 'btn-outline': !mapVisible, 'rounded-full': true}">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="bevel">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
              <input type="checkbox" x-model="mapVisible" class="hidden">
              Map
            </label>
            
            <!-- Combined submit/interrupt button -->
            <button 
              type="button" 
              id="actionButton" 
              @click="isProcessing ? interruptGeneration() : sendMessage()"
              :disabled="!isProcessing && (!inputMessage.trim())"
              class="absolute right-2 bottom-2 p-2 rounded-full transition-colors duration-200"
              :class="isProcessing ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700 disabled:bg-blue-300 disabled:hover:bg-blue-300'"
              :aria-label="isProcessing ? 'Stop generation' : 'Send message'"
            >
              <!-- Stop icon when processing -->
              <svg x-show="isProcessing" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="9" x2="15" y2="15"></line>
                <line x1="15" y1="9" x2="9" y2="15"></line>
              </svg>
              <!-- Send icon when not processing -->
              <svg x-show="!isProcessing" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="bevel">
                <circle cx="12" cy="12" r="10" />
                <path d="M16 12l-4-4-4 4M12 16V9" />
              </svg>
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>
  
  <!-- Scroll to bottom button -->
  <button @click="scrollToBottom()" x-show="showScrollButton"
    class="fixed bottom-24 right-4 bg-blue-600 text-white p-2 rounded-full hover:bg-blue-700 shadow-lg z-20"
    aria-label="Scroll to bottom">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="bevel">
      <path d="M12 5v14M5 12l7 7 7-7" />
    </svg>
  </button>

  <!-- Map panel (col-span-1 when visible) -->
  <div x-show="hasMap && mapVisible" class="col-span-1 relative hidden md:block">
    <div class="sticky top-0 h-screen p-4">
      <div class="h-full flex flex-col">
        <h3 class="text-lg font-bold mb-2">Map Visualization</h3>
        <div id="side-map-container" class="flex-1 rounded-lg shadow-md overflow-hidden"></div>
      </div>
    </div>
  </div>
</div>

<script>
  // Load marked.js for Markdown rendering
  if (!window.marked) {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.4/marked.min.js';
    script.async = true;
    document.head.appendChild(script);
  }

  function chatApp() {
    return {
      ws: null,
      inputMessage: '',
      messages: [],
      currentResponse: null,
      dbUsed: false,
      docsUsed: false,
      isProcessing: false,
      reconnectAttempts: 0,
      maxReconnectAttempts: 5,
      reconnectTimeout: null,
      showScrollButton: false,
      responseStartTime: null,
      hasMap: false, // Track if we have a map to show
      mapVisible: true, // Whether the side map is visible (can be toggled)
      
      init() {
        this.connectWebSocket();
        this.$nextTick(() => {
          this.scrollToBottom();
          this.autoResizeTextarea();
        });
        
        // Add resize event to handle the map resizing
        window.addEventListener('resize', () => {
          if (this.hasMap && this.mapVisible) {
            this.refreshMap();
          }
        });
      },
      
      // Method to interrupt the generation
      interruptGeneration() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN && this.isProcessing) {
          // Send interrupt command to the server
          this.ws.send(JSON.stringify({
            interrupt: true
          }));
          
          // Update the current response to show it was interrupted
          if (this.currentResponse) {
            this.currentResponse.statusUpdates.push("Generation interrupted by user.");
            
            // Finalize the current response even if incomplete
            if (this.responseStartTime) {
              const responseTime = new Date() - this.responseStartTime;
              this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (interrupted)";
              this.responseStartTime = null;
            }
            
            // If there's no answer yet, add a message indicating interruption
            if (!this.currentResponse.answer) {
              this.currentResponse.answer = "*Generation was interrupted.*";
            }
            
            this.currentResponse = null;
          }
          
          // Reset processing state immediately
          this.isProcessing = false;
        }
      },
      
      // Refreshes the side map if needed
      refreshMap() {
        if (this.hasMap && this.mapVisible) {
          // Force Leaflet to recalculate map size
          setTimeout(() => {
            const container = document.getElementById('side-map-container');
            if (container && container._leaflet_id) {
              const map = L.DomUtil.get('side-map-container')._leaflet;
              if (map) {
                map.invalidateSize();
              }
            }
          }, 300);
        }
      },

      // Initialize map with GeoJSON data
      initMap(mapId, geoJSONData) {
        console.log("Initializing map:", mapId);
        
        // Use setTimeout to ensure the DOM is fully ready
        setTimeout(() => {
          const mapContainer = document.getElementById(mapId);
          
          if (!mapContainer) {
            console.error("Map container not found:", mapId);
            return;
          }
          
          try {
            // If map already initialized, don't re-initialize
            if (mapContainer._leaflet_id) {
              console.log("Map already initialized:", mapId);
              return;
            }
            
            // Initialize the map
            const map = L.map(mapId, {
              center: [0, 0],
              zoom: 2
            });
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            // Parse and add the GeoJSON data if it exists
            if (geoJSONData && typeof geoJSONData !== 'undefined') {
              // Convert string to object if needed
              const geoJSON = (typeof geoJSONData === 'string') ? 
                JSON.parse(geoJSONData) : geoJSONData;

              console.log("GeoJSON data:", geoJSON);
              
              if (geoJSON) {
                try {
                  // Create a GeoJSON layer
                  const geoLayer = L.geoJSON(geoJSON).addTo(map);
                  
                  // Try to fit bounds if possible
                  if (geoLayer && geoLayer.getBounds && typeof geoLayer.getBounds === 'function') {
                    const bounds = geoLayer.getBounds();
                    if (bounds && !bounds.isEmpty && !bounds.isEmpty()) {
                      map.fitBounds(bounds, { padding: [30, 30] });
                    }
                  }
                } catch (e) {
                  console.error("Error adding GeoJSON layer:", e);
                }
              } else {
                console.error("Invalid GeoJSON data");
              }
            } else {
              console.warn("No GeoJSON data provided");
              
              // Add a marker at the center as fallback
              L.marker([0, 0]).addTo(map)
                .bindPopup("No GeoJSON data available")
                .openPopup();
            }
            
            // Force map to redraw
            setTimeout(() => {
              map.invalidateSize();
              console.log("Map size refreshed");
            }, 100);
            
            console.log("Map initialization complete for:", mapId);
            
            // Also initialize side map if this is the first GeoJSON we've received
            if (this.hasMap && mapId.includes('mobile-map') && !document.getElementById('side-map-container')._leaflet_id) {
              this.initSideMap(geoJSONData);
            }
          } catch (e) {
            console.error('Error initializing map:', e);
          }
        }, 100); // Short delay to ensure DOM is ready
      },
      
      // Initialize the side map (for desktop view)
      initSideMap(geoJSONData) {
        console.log("Initializing side map");
        
        // Use setTimeout to ensure the DOM is fully ready
        setTimeout(() => {
          const sideMapContainer = document.getElementById('side-map-container');
          
          if (!sideMapContainer) {
            console.error("Side map container not found");
            return;
          }
          
          try {
            // Check if map already exists
            if (sideMapContainer._leaflet_id) {
              console.log("Side map already initialized");
              return;
            }
            
            // Initialize the map
            const sideMap = L.map('side-map-container', {
              center: [0, 0],
              zoom: 2
            });
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(sideMap);
            
            // Parse and add the GeoJSON data if it exists
            if (geoJSONData && typeof geoJSONData !== 'undefined') {
              // Convert string to object if needed
              const geoJSON = (typeof geoJSONData === 'string') ? 
                JSON.parse(geoJSONData) : geoJSONData;
              
              console.log("GeoJSON data for side map:", geoJSON);
              
              if (geoJSON) {
                try {
                  // Create a GeoJSON layer
                  const geoLayer = L.geoJSON(geoJSON).addTo(sideMap);
                  
                  // Try to fit bounds if possible
                  if (geoLayer && geoLayer.getBounds && typeof geoLayer.getBounds === 'function') {
                    const bounds = geoLayer.getBounds();
                    if (bounds && !bounds.isEmpty && !bounds.isEmpty()) {
                      sideMap.fitBounds(bounds, { padding: [30, 30] });
                    }
                  }
                } catch (e) {
                  console.error("Error adding GeoJSON layer to side map:", e);
                }
              } else {
                console.error("Invalid GeoJSON data for side map");
              }
            } else {
              console.warn("No GeoJSON data provided for side map");
              
              // Add a marker at the center as fallback
              L.marker([0, 0]).addTo(sideMap)
                .bindPopup("No GeoJSON data available")
                .openPopup();
            }
            
            // Force map to redraw
            setTimeout(() => {
              sideMap.invalidateSize();
              console.log("Side map size refreshed");
            }, 100);
            
            console.log("Side map initialization complete");
          } catch (e) {
            console.error('Error initializing side map:', e);
          }
        }, 300); // Longer delay for side map to ensure container is visible
      },

      connectWebSocket() {
        const chatID = window.location.pathname.split("/")[2];
        this.ws = new WebSocket(`wss://localhost:4000/ws/${chatID}`);

        this.ws.addEventListener('open', () => {
          console.log('WebSocket connection established');
          this.reconnectAttempts = 0; // Reset reconnect attempts on successful connection
        });

        this.ws.addEventListener('message', (event) => {
          let data = {};
          try {
            data = JSON.parse(event.data);
          } catch (e) {
            console.error('Error parsing JSON:', event.data);
            return;
          }

          // Handle possible interruption acknowledgment
          if (data.interrupted) {
            console.log("Server acknowledged interruption");
            this.isProcessing = false;
            
            if (this.currentResponse) {
              if (!this.currentResponse.answer) {
                this.currentResponse.answer = "*Generation was interrupted.*";
              }
              
              if (this.responseStartTime) {
                const responseTime = new Date() - this.responseStartTime;
                this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (interrupted)";
                this.responseStartTime = null;
              }
              
              this.currentResponse = null;
            }
            
            return;
          }

          // Create response object if it doesn't exist yet
          if (!this.currentResponse) {
            this.messages.push({
              sender: 'AI',
              statusUpdates: [],
              answer: '',
              geoJSON: null
            });
            this.currentResponse = this.messages[this.messages.length - 1];
          }

          // Handle status updates
          if (data.status) {
            this.currentResponse.statusUpdates.push(data.status.trim());
          }

          // Handle answer data
          if (data.answer) {
            this.currentResponse.answer = data.answer;
          }

          // Handle GeoJSON data
          if (data.geoJSON) {
            console.log("Received GeoJSON data");
            this.currentResponse.geoJSON = data.geoJSON;
            this.hasMap = true; // Set hasMap to true when we get GeoJSON data
            
            // Refresh layout to accommodate map
            this.$nextTick(() => {
              this.refreshMap();
            });
          }

          // Finalize the response if we have answer or GeoJSON
          if (data.answer || data.geoJSON) {
            // Calculate response time
            if (this.responseStartTime) {
              const responseTime = new Date() - this.responseStartTime;
              this.currentResponse.responseTime = this.formatResponseTime(responseTime);
              this.responseStartTime = null;
            }
            
            this.currentResponse = null;
            this.isProcessing = false;
          }

          this.$nextTick(() => {
            this.scrollToBottom();
          });
        });

        this.ws.addEventListener('close', (event) => {
          console.log('WebSocket connection closed', event);

          // If we were in the middle of a response, mark it as incomplete
          if (this.isProcessing) {
            if (this.currentResponse) {
              this.currentResponse.statusUpdates.push("Connection closed unexpectedly. Please try again.");
              this.currentResponse.answer = this.currentResponse.answer || "Response interrupted. Please try again.";

              // Add response time even for incomplete responses
              if (this.responseStartTime) {
                const responseTime = new Date() - this.responseStartTime;
                this.currentResponse.responseTime = this.formatResponseTime(responseTime) + " (incomplete)";
                this.responseStartTime = null;
              }

              this.currentResponse = null;
            }
            this.isProcessing = false;
          }

          // Attempt to reconnect if not a normal closure and within max attempts
          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
            const delay = Math.min(1000 * Math.pow(1.5, this.reconnectAttempts), 10000);
            console.log(`Attempting to reconnect in ${delay}ms...`);

            this.reconnectTimeout = setTimeout(() => {
              this.reconnectAttempts++;
              this.connectWebSocket();
            }, delay);
          }
        });

        this.ws.addEventListener('error', (error) => {
          console.error('WebSocket error:', error);
        });
      },

      sendMessage() {
        if (!this.inputMessage.trim() || this.isProcessing) return;

        // Check WebSocket state
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
          console.error('WebSocket is not open');
          // Try to reconnect
          if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
          }
          this.connectWebSocket();
          return;
        }

        this.isProcessing = true; // Disable input form while processing
        this.responseStartTime = new Date(); // Start timing the response

        this.messages.push({
          sender: 'You',
          text: this.inputMessage
        });

        this.messages.push({
          sender: 'AI',
          statusUpdates: [],
          answer: '',
          geoJSON: null
        });

        this.currentResponse = this.messages[this.messages.length - 1];

        this.ws.send(JSON.stringify({
          message: this.inputMessage,
          dbUsed: this.dbUsed,
          docsUsed: this.docsUsed
        }));

        this.inputMessage = '';
        this.$nextTick(() => {
          this.scrollToBottom();
          this.autoResizeTextarea();
        });
      },

      scrollToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      },

      checkScroll() {
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          // Show button if user has scrolled up at least 200px from bottom
          this.showScrollButton = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight > 200;
        }
      },

      formatResponseTime(milliseconds) {
        if (milliseconds < 1000) {
          return `${milliseconds}ms`;
        } else if (milliseconds < 60000) {
          return `${(milliseconds / 1000).toFixed(1)}s`;
        } else {
          const minutes = Math.floor(milliseconds / 60000);
          const seconds = ((milliseconds % 60000) / 1000).toFixed(1);
          return `${minutes}m ${seconds}s`;
        }
      },

      formatMarkdown(text) {
        if (!text) return '';
        // Make sure marked is loaded
        if (window.marked) {
          try {
            return window.marked.parse(text);
          } catch (e) {
            console.error('Error parsing markdown:', e);
            return text;
          }
        }
        return text; // Fallback if marked.js isn't loaded yet
      },

      autoResizeTextarea() {
        const textarea = this.$refs.messageInput;
        if (textarea) {
          // Reset height to get proper scrollHeight
          textarea.style.height = 'auto';

          // Set new height (with min/max constraints handled by CSS)
          const newHeight = Math.min(Math.max(textarea.scrollHeight, 60), 200);
          textarea.style.height = `${newHeight}px`;
        }
      }
    }
  }
</script>
<style>
  /* Ensure Leaflet is styled properly */
  #side-map-container {
    min-height: 300px;
    height: calc(100vh - 120px);
    width: 100%;
    z-index: 1;
  }
  
  [class*="mobile-map-"] {
    min-height: 250px;
  }
  
  /* Markdown content styling */
  .markdown-content h1 {
    font-size: 1.8em;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
  }

  .markdown-content h2 {
    font-size: 1.5em;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
  }

  .markdown-content h3 {
    font-size: 1.3em;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
  }

  .markdown-content h4 {
    font-size: 1.1em;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
  }

  .markdown-content p {
    margin-bottom: 1em;
  }

  .markdown-content ul,
  .markdown-content ol {
    margin-left: 2em;
    margin-bottom: 1em;
  }

  .markdown-content ul {
    list-style-type: disc;
  }

  .markdown-content ol {
    list-style-type: decimal;
  }

  .markdown-content li {
    margin-bottom: 0.5em;
  }

  .markdown-content pre {
    background-color: #f0f0f0;
    padding: 0.5em;
    border-radius: 0.25em;
    overflow-x: auto;
    margin-bottom: 1em;
  }

  .markdown-content code {
    font-family: monospace;
    background-color: #f0f0f0;
    padding: 0.2em 0.4em;
    border-radius: 0.25em;
  }

  .markdown-content pre code {
    padding: 0;
    background-color: transparent;
  }

  .markdown-content blockquote {
    border-left: 4px solid #ccc;
    padding-left: 1em;
    margin-left: 0;
    margin-bottom: 1em;
  }

  .markdown-content a {
    color: #3182ce;
    text-decoration: underline;
  }

  .markdown-content table {
    border-collapse: collapse;
    margin-bottom: 1em;
  }

  .markdown-content th,
  .markdown-content td {
    border: 1px solid #ccc;
    padding: 0.5em;
  }

  /* Dark mode adjustments */
  .dark .markdown-content pre,
  .dark .markdown-content code {
    background-color: #2d3748;
  }

  .dark .markdown-content a {
    color: #63b3ed;
  }

  .dark .markdown-content blockquote {
    border-left-color: #4a5568;
  }

  .dark .markdown-content th,
  .dark .markdown-content td {
    border-color: #4a5568;
  }
</style>
{{end}}